# 스택(Stack)

스택(Stack)은 **후입선출(LIFO, Last-In First-Out)** 방식으로 동작하는 선형 자료구조입니다.  
스택에서 데이터는 한 쪽 끝에서만 삽입(Push)되고, 같은 쪽에서만 삭제(Pop)됩니다.

## 기본 연산

1. **Push**: 데이터를 스택에 추가하는 연산.
2. **Pop**: 스택에서 데이터를 꺼내는 연산.
3. **Peek**: 스택에서 가장 위에 있는 데이터를 확인하는 연산, 삭제하지 않음.
4. **Size**: 스택에 현재 저장된 원소의 개수를 반환.
5. **IsEmpty**: 스택이 비어 있는지 여부를 확인하는 연산.

## 스택에서 발생하는 오류

- **언더플로우 (Underflow)**: 스택이 비어 있는 상태에서 `Pop` 연산을 시도할 때 발생합니다.
- **오버플로우 (Overflow)**: 스택이 가득 찬 상태에서 `Push` 연산을 시도할 때 발생합니다.

## 스택 구현 방법

1. **배열을 이용한 스택 구현**  
   - Python의 리스트를 이용하여 스택을 구현할 수 있습니다.  
   - `append()`로 데이터를 추가하고, `pop()`으로 데이터를 꺼냅니다.

2. **연결 리스트를 이용한 스택 구현**  
   - 양방향 연결 리스트를 이용하여 스택을 구현할 수 있습니다. 이 경우, `push`와 `pop` 연산이 O(1)로 수행됩니다.

## 알고리즘: 수식 괄호 유효성 검사

스택을 사용하여 수식에서 괄호가 올바르게 짝지어졌는지 확인할 수 있습니다. **여는 괄호**는 스택에 푸시하고, **닫는 괄호**는 스택에서 꺼내면서 유효성을 검사합니다.

### 알고리즘 설계

1. **왼쪽부터 한 글자씩 읽기**:
   - **여는 괄호**(`(`, `{`, `[`)를 만나면 스택에 푸시합니다.
   - **닫는 괄호**(`)`, `}`, `]`)를 만나면:
     - 스택이 비어 있으면 올바르지 않은 수식입니다.
     - 스택에서 꺼낸 여는 괄호와 짝이 맞는지 확인합니다.
     - 짝이 맞지 않으면 올바르지 않은 수식입니다.
   
2. **끝까지 검사한 후**, 스택이 비어 있으면 괄호가 모두 짝지어진 것입니다.

## 스택의 특징
- **Push 연산과 Pop 연산이 O(1)**로 시간 복잡도가 매우 효율적입니다.
- 괄호 유효성 검사와 같은 문제에 유용하게 사용됩니다.


# 스택의 응용 – 수식의 후위 표기법

## 중위 표기법과 후위 표기법

- **중위 표기법 (Infix notation)**: 연산자가 피연산자들 사이에 위치합니다.  
  예시: `(A + B) * (C + D)`

  - **후위 표기법 (Postfix notation)**: 연산자가 피연산자들의 뒤에 위치합니다.  
예시: `AB+CD+*`


## 중위 표현식을 후위 표현식으로 변환하는 방법

- **스택을 이용한 후위 표기법 변환**
  - 연산자간의 우선순위를 따져 스택에 집어넣고, 피연산자는 그때그때 출력하는 방식입니다.

**변환 예시**:
- `A + B + C` → `AB+C+`
- `A + B * C` → `ABC*+`
- `(A + B) * C` → `AB+C*`
- `A * (B + C)` → `ABC+*`
- `(A + (B - C)) * D` → `ABC-+D*`
- `(A * (B - (C + D)))` → `ABCD+-*`

## 알고리즘 설계

1. **연산자의 우선순위 설정**
 - 예를 들어 `*`와 `/`는 `+`와 `-`보다 우선순위가 높습니다.
 - 괄호는 가장 높은 우선순위를 가집니다.

2. **중위 표현식을 왼쪽부터 한 글자씩 읽기**:
 - **피연산자** (A, B, C 등)이면 그대로 출력.
 - **여는 괄호 '('**이면 스택에 푸시.
 - **닫는 괄호 ')'**이면 여는 괄호 '('가 나올 때까지 스택에서 팝하고 출력.
 - **연산자**이면 스택에서 이 연산자보다 높은 (또는 같은) 우선순위의 연산자들을 모두 팝하고 출력, 그리고 연산자는 스택에 푸시.

3. **스택에 남아 있는 연산자 모두 팝하고 출력**:
 - 스택에 남아 있는 연산자들은 모두 팝하여 출력합니다.

## 알고리즘 흐름

1. **연산자 우선순위 비교**:
 - 스택에 있는 연산자와 새로운 연산자의 우선순위를 비교하여 스택에 푸시할지, 팝할지 결정합니다.
 - 이를 위해 스택의 `peek()` 메서드를 사용하여 맨 위의 연산자를 확인할 수 있습니다.

2. **스택이 비어 있을 때까지 팝**:
 - 수식을 모두 처리한 후, 스택에 남아 있는 연산자들을 모두 팝하여 출력합니다. 이 때 `isEmpty()` 메서드를 사용하여 스택이 비어 있는지 확인할 수 있습니다.

 ## 스택의 중요성
 - 후위 표기법으로 수식을 변환하면 연산 순서를 명확히 할 수 있으며, 계산 과정에서 괄호를 처리할 필요가 없습니다.
- 스택을 사용하여 중위 표기법을 후위 표기법으로 변환하면 연산자 우선순위 문제를 쉽게 처리할 수 있습니다.


# 스택의 응용 – 후위 표기 수식 계산

## 후위 표기법 수식 계산

후위 표기법(Postfix notation)으로 표현된 수식을 계산하는 방법은 스택을 사용하여 효율적으로 해결할 수 있습니다. 예를 들어, 후위 표기법 수식 `AB+CD+*`은 중위 표기법으로 `(A + B) * (C + D)`와 동일합니다.

## 알고리즘 설계

후위 표기법 수식을 계산하는 과정은 다음과 같습니다:

1. **후위 표현식을 왼쪽부터 한 글자씩 읽기**:
   - **피연산자**(숫자 또는 변수)이면 스택에 푸시(push).
   - **연산자**(기호: `+`, `-`, `*`, `/` 등)를 만나면 스택에서 두 개의 값을 pop:
     1. 두 번째 값 (두 번째 피연산자)
     2. 첫 번째 값 (첫 번째 피연산자)
     - 이 두 값을 이용하여 연산을 수행하고 그 결과를 다시 스택에 푸시.

2. **수식의 끝에 도달하면**:
   - 스택에 남아 있는 값이 최종 계산 결과가 됩니다.

## 알고리즘 흐름

1. **피연산자**는 스택에 푸시.
2. **연산자**가 나오면 스택에서 두 개의 값을 pop하고 계산 후 그 결과를 다시 스택에 푸시.
3. 수식을 끝까지 처리한 후, 스택에 남아 있는 값이 최종 계산 결과입니다.

## 스택을 사용한 후위 표기법의 장점
- 후위 표기법은 괄호 없이 계산 순서를 정확하게 알 수 있기 때문에 수식 계산에서 매우 효율적입니다.
- 연산자 우선순위나 괄호 처리 문제를 자동으로 해결할 수 있어 계산이 간단하고 명확합니다.