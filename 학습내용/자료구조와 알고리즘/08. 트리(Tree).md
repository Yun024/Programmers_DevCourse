# 트리 (Tree) – 이차원 자료 구조

트리는 **정점(Node)**과 **간선(Edge)**을 이용하여 데이터를 계층적으로 배치한 자료 구조입니다. 트리는 다양한 형태로 분류되며, 그 구조는 부모와 자식 관계를 통해 데이터를 표현합니다.

## 트리의 기본 용어

- **루트(Root) 노드**: 트리의 최상위 노드로, 트리 구조의 시작점입니다.
- **내부(Internal) 노드**: 자식 노드를 가지는 노드.
- **리프(Leaf) 노드**: 자식 노드를 가지지 않는 노드, 트리의 마지막에 위치합니다.
- **부모(Parent) 노드**: 자식 노드를 가지는 노드로, 트리의 상위에 위치합니다.
- **자식(Child) 노드**: 부모 노드에 연결된 하위 노드입니다.
- **형제(Sibling)**: 같은 부모 노드를 가진 노드들.
- **조상(Ancestor)**: 부모의 부모(의 부모..)로 거슬러 올라간 노드들.
- **후손(Descendant)**: 자식의 자식(의 자식..)으로 내려간 노드들.
- **노드의 수준(Level)**: 루트 노드의 수준은 0부터 시작하며, 간선 하나당 1씩 증가합니다.
- **트리의 높이(Height 또는 Depth)**: 트리의 최대 수준(Level) + 1.
- **부분 트리(Subtree)**: 특정 노드를 기준으로 나뉜 트리.
- **차수(Degree)**: 노드가 가진 자식의 수. 0이면 리프 노드입니다.

## 이진 트리 (Binary Tree)

이진 트리는 **모든 노드의 차수가 2 이하인 트리**입니다. 이진 트리는 재귀적으로 정의할 수 있습니다: 빈 트리이거나, 루트 노드와 왼쪽 서브트리, 오른쪽 서브트리로 구성됩니다.

### 이진 트리의 종류

1. **포화 이진 트리(Full Binary Tree)**: 모든 레벨에서 노드들이 모두 채워져 있는 이진 트리입니다. 이진 트리의 높이가 k일 때, 노드의 개수는 `2^k - 1`입니다.
   
2. **완전 이진 트리(Complete Binary Tree)**: 높이가 k인 이진 트리로, 레벨 k-2까지는 모든 노드가 2개의 자식을 가지며, 레벨 k-1에서는 왼쪽부터 순차적으로 노드가 채워집니다.

## 이진 트리의 추상적 자료구조

### 연산의 정의

- **size()**: 트리에 포함된 노드의 총 수를 구합니다.
- **depth()**: 트리의 깊이 또는 높이를 구합니다.

### 순회(Traversal)

이진 트리에서의 노드는 다음과 같은 구조로 구성됩니다:
- **Node**: 각 노드는 `Data`, `Left Child`, `Right Child`를 가집니다.

## 트리의 시각적 예시
          A
         / \
        B   C
       / \   \
      D   E   F
- size()는 6입니다.
- depth()는 3입니다.
- 노드 A는 루트 노드, B와 C는 내부 노드, D, E, F는 리프 노드입니다.

## 결론
트리는 계층적 관계를 표현하는 데 유용한 자료 구조로, 데이터 구조에서 자주 사용됩니다. 이진 트리는 다양한 알고리즘 문제에서 중요한 역할을 하며, 트리의 다양한 형태는 각기 다른 용도에 맞춰 활용됩니다.


# 순회 (Traversal)

트리 자료구조에서 순회(Traversal)는 트리의 모든 노드를 방문하는 과정입니다. 순회 방식에는 **깊이 우선 순회 (Depth First Traversal)**과 **넓이 우선 순회 (Breadth First Traversal)**가 있습니다. 각 순회 방식은 트리의 노드를 방문하는 순서가 다릅니다.

## 깊이 우선 순회 (Depth First Traversal)

깊이 우선 순회는 **하나의 분기(branch)를 깊게 탐색한 후**, 다른 분기를 탐색하는 방식입니다. 이 방식에는 세 가지 주요 순회 방법이 있습니다:

       A
      / \
     B   C
    / \
   D   E

1. **중위 순회 (In-order Traversal)**:
- 순서: `left subtree → 자기 자신 → right subtree`
- 설명: 왼쪽 서브트리, 현재 노드, 오른쪽 서브트리의 순서로 방문합니다.

중위 순회의 방문 순서: `D → B → E → A → C`

2. **전위 순회 (Pre-order Traversal)**:
- 순서: `자기 자신 → left subtree → right subtree`
- 설명: 현재 노드, 왼쪽 서브트리, 오른쪽 서브트리의 순서로 방문합니다.

전위 순회의 방문 순서: `A → B → D → E → C`

3. **후위 순회 (Post-order Traversal)**:
- 순서: `left subtree → right subtree → 자기 자신`
- 설명: 왼쪽 서브트리, 오른쪽 서브트리, 현재 노드의 순서로 방문합니다.

후위 순회의 방문 순서: `D → E → B → C → A`

## 넓이 우선 순회 (Breadth First Traversal)

넓이 우선 순회는 **수준(level)이 낮은 노드를 우선으로 방문**하는 방식입니다. 같은 수준의 노드들 사이에서는 **부모 노드의 방문 순서에 따라** 방문하며, 왼쪽 자식 노드를 오른쪽 자식보다 먼저 방문합니다. 이 방식은 재귀적 방법이 적합하지 않으며, **Queue**를 사용하여 구현합니다.

넓이 우선 순회의 방문 순서 `A → B → C → D → E`

### 넓이 우선 순회 구현

1. **초기화**: `traversal <- 빈 리스트`, `q <- 빈 큐`
2. **빈 트리가 아니면**, `root node`를 큐에 추가(`enqueue`)
3. **큐가 비어 있지 않은 동안**:
- 3.1 큐에서 원소를 추출 (`dequeue`)
- 3.2 추출된 노드를 방문
- 3.3 노드의 왼쪽, 오른쪽 자식(있으면)을 큐에 추가
4. **큐가 비게 되면** 모든 노드의 방문이 완료됩니다.


# 이진 탐색 트리 (Binary Search Tree, BST)

이진 탐색 트리는 **모든 노드에 대해** 아래와 같은 성질을 만족하는 트리 구조입니다:
- 왼쪽 서브트리에 있는 데이터는 모두 현재 노드의 값보다 작고
- 오른쪽 서브트리에 있는 데이터는 모두 현재 노드의 값보다 큽니다.

이진 탐색 트리는 **중복된 데이터** 원소를 허용하지 않습니다.

## 이진 탐색 트리와 배열의 비교

### 장점
- 데이터 원소의 추가, 삭제가 용이합니다. 트리 구조이기 때문에 원하는 위치에 쉽게 원소를 추가하거나 삭제할 수 있습니다.

### 단점
- 공간 소요가 큽니다. 이진 탐색 트리는 트리 구조에 따라 추가적인 메모리 공간이 필요합니다.

## 이진 탐색 트리의 추상적 자료구조

### 데이터 표현
- 각 노드는 `(key, value)`의 쌍으로 표현됩니다.
- 키를 이용해서 원소를 검색할 수 있으며, 보다 복잡한 데이터 레코드로 확장할 수 있습니다.

### 연산의 정의
- **insert(key, data)**: 트리에 주어진 데이터 원소를 추가합니다.
- **remove(key)**: 특정 원소를 트리에서 삭제합니다.
- **lookup(key)**: 특정 원소를 검색합니다.
- **inorder()**: 키의 순서대로 데이터 원소를 나열합니다.
- **min(), max()**: 최소 키, 최대 키를 가지는 원소를 각각 탐색합니다.

### 이진 탐색 트리에서 원소 삭제

1. **키를 이용해 노드를 찾기**:
   - 해당 키의 노드가 없으면 삭제할 것도 없습니다.
   - 찾은 노드의 부모 노드도 필요합니다 (아래의 구조 정리 때문).

2. **삭제 후 트리의 구조 정리**:
   - 삭제한 노드를 제거한 후, 이진 탐색 트리의 성질을 만족하도록 트리 구조를 수정합니다.

#### 삭제되는 노드의 경우
- **말단 (leaf) 노드인 경우**: 자식이 없으므로 간단히 삭제합니다.
- **자식을 하나 가진 경우**: 자식 노드를 부모에 연결하여 삭제합니다.
- **자식을 둘 가진 경우**: 자식 중 하나를 교체하여 삭제합니다.

### 인터페이스 설계
- **입력**: 키(Key)
- **출력**: 
  - 삭제할 경우 `True`
  - 해당 키의 노드가 없는 경우 `False`

### 이진 탐색 트리가 효율적이지 못한 경우

- 트리가 **한쪽으로 치우쳐** 비대칭적인 경우, 즉 트리의 **높이 균형이 잡히지 않은 경우** 성능이 떨어집니다.

## 보다 나은 성능을 보이는 이진 탐색 트리

- 이진 탐색 트리의 성능은 **높이 균형**에 크게 의존합니다. 균형을 유지하면 탐색이 효율적으로 이루어집니다.
- 균형을 유지하는 다양한 이진 탐색 트리 구현들이 존재하며, 이들은 평균적으로 O(logn)의 탐색 복잡도를 보장합니다.
- 그러나 삽입 및 삭제 연산은 더 복잡할 수 있습니다.

### 예시
- **AVL 트리 (AVL Tree)**: 자동으로 균형을 맞추는 이진 탐색 트리입니다.
- **레드-블랙 트리 (Red-Black Tree)**: 또 다른 균형 잡힌 이진 탐색 트리로, 특정 조건을 만족하는 트리입니다.

이러한 트리들은 높이를 균형 있게 유지함으로써 탐색, 삽입, 삭제의 성능을 보장합니다.


# 힙 (Heap)

힙(Heap)은 이진 트리의 한 종류로, 다음과 같은 특성을 가집니다:
1. 루트(root) 노드가 항상 최댓값 또는 최솟값을 가집니다.
   - 최대 힙 (Max Heap): 루트가 최댓값을 가짐.
   - 최소 힙 (Min Heap): 루트가 최솟값을 가짐.
2. 완전 이진 트리여야 합니다. 즉, 트리의 모든 레벨이 완전히 채워져 있어야 하며, 마지막 레벨만 예외적으로 왼쪽부터 차례로 채워집니다.

힙은 느슨한 정렬을 가지고 있으며, 특정 키 값을 가지는 원소를 검색할 수 없습니다. 

## 최대 힙 (Max Heap)

최대 힙에서는 루트 노드가 가장 큰 값을 가지며, 각 서브트리도 최대 힙의 특성을 만족해야 합니다.

### 연산의 정의
- `__init__()`: 빈 최대 힙을 생성합니다.
- `insert(item)`: 새로운 원소를 최대 힙에 삽입합니다.
- `remove()`: 최대 원소(root node)를 반환하고, 이 원소를 삭제합니다.

### 데이터 표현 설계
배열을 이용해 이진 트리를 표현합니다.
- 왼쪽 자식의 번호: `2 * m`
- 오른쪽 자식의 번호: `2 * m + 1`
- 부모 노드의 번호: `m // 2`

완전 이진 트리이므로, 노드의 추가 및 삭제는 항상 마지막 노드에서만 이루어집니다.

## 최대 힙에 원소 삽입
1. 트리의 마지막 자리에 새로운 원소를 임시로 저장합니다.
2. 부모 노드와 비교하여, 크기가 더 큰 부모 노드와 교환하면서 위로 이동합니다.

### 삽입 연산 복잡도
- 원소의 개수가 `N`인 최대 힙에서 새로운 원소를 삽입하는 데 드는 최대 시간은 `O(log n)`입니다.
  - 최악의 경우: 삽입한 원소가 트리의 루트까지 올라가야 할 수 있습니다.

## 최대 힙에서 원소 삭제
1. 루트 노드를 제거합니다. 이 루트 노드는 원소들 중 최댓값입니다.
2. 트리의 마지막 노드를 임시로 루트 노드 자리에 배치합니다.
3. 루트와 자식 노드들의 값을 비교하여, 더 큰 자식과 교환하면서 아래로 이동합니다.

### 삭제 연산 복잡도
- 원소의 개수가 `N`인 최대 힙에서 최대 원소를 삭제하는 데 드는 최대 시간은 `O(log n)`입니다.
  - 최악의 경우: 삭제된 원소가 트리의 맨 끝까지 내려가야 할 수 있습니다.

## 최대 힙 / 최소 힙의 응용

### 1. 우선순위 큐 (Priority Queue)
- Enqueue할 때는 원소들을 "느슨한 정렬" 상태로 유지하도록 하여 `O(log n)`의 시간 복잡도를 가집니다.
- Dequeue할 때는 우선순위에 따라 원소들을 순차적으로 추출할 수 있습니다. 이 또한 `O(log n)`의 시간 복잡도를 가집니다.
- 우선순위 큐는 양방향 연결 리스트에 비해 시간적인 장점이 있습니다.

### 2. 힙 정렬 (Heap Sort)
- 정렬되지 않은 원소들을 최대 힙에 삽입합니다. 삽입은 `O(log n)`의 시간 복잡도를 가집니다.
- 삽입이 끝나면, 힙에서 원소들을 하나씩 삭제하여 정렬된 순서대로 나옵니다. 삭제도 `O(log n)`의 시간 복잡도를 가집니다.
- 힙 정렬의 복잡도: `O(n log n)`입니다. (삽입과 삭제가 각각 `O(log n)`이므로 전체적으로 `O(n log n)`이 됩니다.)
