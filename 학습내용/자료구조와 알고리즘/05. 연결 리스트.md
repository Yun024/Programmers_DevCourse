# 연결 리스트 (Linked List) – 클래스를 사용해서 표현

연결 리스트는 **추상적 자료구조**로, 데이터를 효율적으로 저장하고 조작할 수 있도록 설계되었습니다. 배열과 달리, 노드(Node)들이 포인터를 통해 서로 연결된 형태로 이루어져 있습니다.

---

## 연결 리스트의 구성 요소
- **노드(Node)**: 데이터를 저장하며, 다음 노드의 주소(포인터)를 가짐.
  - `Data`: 정수, 문자열, 레코드 등 저장 가능한 데이터.
  - `Link(next)`: 다음 노드를 가리키는 포인터.
- **Head**: 연결 리스트의 첫 번째 노드.
- **Tail**: 연결 리스트의 마지막 노드.
- **노드 수**: 연결 리스트의 총 노드 개수.

---

## 주요 연산 정의

### 1. 특정 원소 참조
- k번째 원소를 탐색하기 위해 첫 노드부터 선형 탐색을 수행.
- 시간 복잡도: **O(n)**

### 2. 리스트 순회
- 리스트의 모든 원소를 순차적으로 방문.

### 3. 리스트 길이 얻기
- 리스트에 포함된 노드의 총 개수를 반환.

---

## 배열과 연결 리스트의 비교

| **특성**        | **배열**                   | **연결 리스트**             |
|------------------|----------------------------|-----------------------------|
| **저장 공간**   | 연속한 메모리 위치에 저장 | 임의의 메모리 위치에 저장   |
| **특정 원소 참조** | 매우 간편, **O(1)**        | 선형 탐색, **O(n)**         |
| **크기 조정**   | 고정된 크기                 | 동적 크기 조정 가능         |

---

## 주의사항
연결 리스트는 저장 공간의 효율적 활용과 동적 크기 조정에서 유리하지만, 특정 원소 접근이나 탐색에서는 배열에 비해 느릴 수 있습니다. 문제의 특성과 요구사항에 따라 적합한 자료구조를 선택하는 것이 중요합니다

# 연결 리스트 (2) – 삽입, 삭제 및 연산

연결 리스트는 동적 자료구조로, 삽입과 삭제가 매우 유연합니다. 이를 구현하기 위한 다양한 메서드를 설계하고, 효율성을 고려하여 연산을 수행합니다.

---

## 원소 삽입

### `insertAt(self, pos, newNode)`
- **기능**: 지정된 위치 `pos`(1 ≤ `pos` ≤ `nodeCount+1`)에 `newNode`를 삽입. 성공 시 `True`, 실패 시 `False`를 반환.
- **주의사항**:
  1. 삽입 위치가 리스트 맨 앞일 경우:
     - `prev` 노드 없음.
     - `Head` 조정 필요.
  2. 삽입 위치가 리스트 맨 끝일 경우:
     - `Tail` 조정 필요.
  3. 빈 리스트에서의 삽입은 위 두 조건으로 처리.
- **복잡도**:
  - 맨 앞 삽입: **O(1)**
  - 중간 삽입: **O(n)**
  - 맨 끝 삽입: **O(1)** (Tail 포인터를 통해 실행)

---

## 원소 삭제

### `popAt(self, pos)`
- **기능**: 지정된 위치 `pos`(1 ≤ `pos` ≤ `nodeCount`)의 노드를 삭제하고 해당 노드의 데이터를 반환.
- **주의사항**:
  1. 삭제 위치가 리스트 맨 앞일 경우:
     - `prev` 노드 없음.
     - `Head` 조정 필요.
  2. 삭제 위치가 리스트 맨 끝일 경우:
     - `Tail` 조정 필요.
  3. 리스트의 유일한 노드를 삭제할 경우:
     - 특별히 처리.
- **복잡도**:
  - 맨 앞 삭제: **O(1)**
  - 중간 삭제: **O(n)**
  - 맨 끝 삭제: **O(n)** (중간 탐색 필요)

---

## 두 리스트 연결

### `concat(self, L)`
- **기능**: 연결 리스트 `self`의 뒤에 또 다른 연결 리스트 `L`을 이어 붙임.
- **효율성**: `Tail` 포인터를 통해 쉽게 구현 가능.

---

## 연결 리스트의 장점
- 삽입과 삭제가 **유연**.
- 예: 모바일의 홈 버튼에서 창을 나열하거나, 창을 위로 밀어 삭제하고, 새로운 항목을 삽입하는 기능.
- 최대 장점: **삽입과 삭제**가 효율적으로 구현 가능.

---

## 새로운 메서드 설계

### `insertAfter(prev, newNode)`
- **기능**: `prev` 노드 뒤에 `newNode`를 삽입.
- **처리**:
  - `prev`가 마지막 노드인 경우 `Tail` 조정 필요.
  - 리스트가 비어 있는 경우 처리.

### `popAfter(prev)`
- **기능**: `prev` 노드의 다음 노드를 삭제하고 데이터 반환.
- **주의사항**:
  - `prev.next`가 `None`인 경우 삭제할 노드 없음.

---

## 더미 노드를 활용한 연결 리스트
- **구조**: 리스트 맨 앞에 **더미 노드(dummy node)**를 추가.
  - `Head`: 더미 노드.
  - `Tail`: 마지막 노드.
- **장점**: 삽입, 삭제 연산에서 맨 앞 노드와 일반 노드를 동일하게 처리 가능.
※ 연결 리스트는 삽입과 삭제가 유연하다는 점에서 큰 장점을 가집니다. 더미 노드를 활용하면 특별한 경우를 통합적으로 처리할 수 있어 코드의 단순화와 효율성을 높일 수 있습니다.


# 양방향 연결 리스트 (Doubly Linked List)

양방향 연결 리스트는 한 방향으로만 링크를 연결하는 대신, **앞으로도 (다음 노드)**, **뒤로도 (이전 노드)** 링크를 갖는 연결 리스트입니다. 이를 통해 리스트 순회를 더 유연하고 효율적으로 할 수 있습니다.

---

## 양방향 연결 리스트의 특징

1. **양방향 링크**: 각 노드는 두 개의 링크를 가집니다.
   - **`next`**: 다음 노드를 가리키는 포인터.
   - **`prev`**: 이전 노드를 가리키는 포인터.
   
2. **리스트 처음과 끝에 더미 노드 (Dummy Node)**를 추가하여 예외 처리를 간소화합니다.
   - **`self.head`**: 리스트의 시작을 가리키는 더미 노드.
   - **`self.tail`**: 리스트의 끝을 가리키는 더미 노드.

## 양방향 연결 리스트의 장점
- 양방향 순회: 노드를 양방향으로 탐색할 수 있어 순회가 유연하고 빠릅니다.
- 효율적인 삽입 및 삭제: 노드를 삽입하거나 삭제할 때 prev와 next 링크를 효율적으로 처리할 수 있습니다.
- 더 적은 예외 처리: 더미 노드를 추가함으로써, 리스트가 비어있거나 한 개의 노드만 있을 때 예외 처리를 간소화할 수 있습니다.

※ 양방향 연결 리스트는 삽입과 삭제에서 큰 장점을 가지며, 특히 양방향 탐색이 가능하여 데이터의 위치를 더 유연하게 찾을 수 있습니다. 이는 리스트의 동적 크기 조정이 필요할 때 매우 유용합니다.
